### 1. TS中的原始类型

- number

- string

- boolean

- null
  
  - TypeScript 中，null 与 undefined 类型都是**有具体意义的类型**。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 `strictNullChecks` 检查的情况下，会被视作其他类型的子类型

- undefined

- object

- bigint

- symbol

- void
  
  - TypeScript 的原始类型标注中也有 void，但与 JavaScript 中不同的是，这里的 void 用于描述一个内部没有 return 语句, 或者没有显式 return 一个值的函数的返回值
  
  - 你可以认为 void 表示一个空类型，而 null 与 undefined 都是一个具有意义的实际类型

### 2. 数组类型

- 数组

- 元组



### 3.对象类型

- 在 TypeScript 中我们也需要特殊的类型标注来描述对象类型，即 interface 

- 每一个属性的值必须**一一对应**到接口的属性类型

- 不能有多的属性，也不能有少的属性，包括直接在对象内部声明，或是 `obj1.other = 'xxx'` 这样属性访问赋值的形式

- **在任何情况下，都不应该使用装箱类型。**

#### type与类型别名

     1. interface 用来描述**对象、类的结构**

     2. 类型别名用来**将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型**

#### 为了更好地区分 `Object`、`object` 以及`{}`这三个具有迷惑性的类型，我们再做下总结：

- 在任何时候都**不要，不要，不要使用** Object 以及类似的装箱类型。
- 当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 object。但我更推荐进一步区分，也就是使用 `Record<string, unknown>` 或 `Record<string, any>` 表示对象，`unknown[]` 或 `any[]` 表示数组，`(...args: any[]) => any`表示函数这样。
- 我们同样要避免使用`{}`。`{}`意味着任何非 `null / undefined` 的值，从这个层面上看，使用它和使用 `any` 一样恶劣。



### 4.字面量类型

- 代表着比原始类型更精确的类型，同时也是原始类型的子类型

- 字面量类型主要包括**字符串字面量类型**、**数字字面量类型**、**布尔字面量类型**和**对象字面量类型**

- **无论是原始类型还是对象类型的字面量类型，它们的本质都是类型而不是值**

### 5.联合类型

- 代表了**一组类型的可用集合**，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型

- 对于联合类型中的函数类型，需要使用括号`()`包裹起来

- 函数类型并不存在字面量类型，因此这里的 `(() => {})` 就是一个合法的函数类型

- 你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中

### 6.枚举

- enum



### 7. 函数与class类型

- 函数的类型就是描述了**函数入参类型与函数返回值类型**

#### 重载

- 基于重载签名，我们就实现了将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力。
  
  这里有一个需要注意的地方，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。因此在第一个重载声明中，为了与逻辑中保持一致，即在 bar 为 true 时返回 string 类型，这里我们需要将第一个重载声明的 bar 声明为必选的字面量类型。

### class

- class的主要结构只有**构造函数**、**属性**、**方法**和**访问符（*Accessor*）**

- 在 TypeScript 中我们能够为 Class 成员添加这些修饰符：`public` / `private` / `protected` / `readonly`

- 除 readonly 以外，其他三位都属于访问性修饰符，而 readonly 属于操作性修饰符

- 在类的内部静态成员无法通过 this 来访问，需要通过 `Foo.staticHandler` 这种形式进行访问

- **抽象类**。抽象类是对类结构与方法的抽象，简单来说，**一个抽象类描述了一个类中应当有哪些成员（属性、方法等）**，**一个抽象方法描述了这一方法在实际实现中的结构**.抽象方法其实描述的就是这个方法的**入参类型**与**返回值类型**



### 8. 内置类型: any, unknown, never, 类型断言

- any 类型的主要意义，其实就是为了表示一个**无拘无束的“任意类型”，它能兼容所有类型，也能够被所有类型兼容**。这一作用其实也意味着类型世界给你开了一个外挂，无论什么时候，你都可以使用 any 类型跳过类型检查

- 如果是类型不兼容报错导致你使用 any，考虑用类型断言替代

- 如果是类型太复杂导致你不想全部声明而使用 any，考虑将这一处的类型去断言为你需要的最简类型。

- 如果你是想表达一个未知类型，更合理的方式是使用 unknown



- unknown 类型和 any 类型有些类似，一个 unknown 类型的变量可以再次赋值为任意其它类型，但只能赋值给 any 与 unknown 类型的变量

- 要对 unknown 类型进行属性访问，需要进行类型断言

- 在编程语言的类型系统中，never 类型被称为 **Bottom Type**，是**整个类型系统层级中最底层的类型**。和 null、undefined 一样，它是所有类型的子类型，但只有 never 类型的变量能够赋值给另一个 never 类型变量。

#### 类型断言

- 类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。它其实就是一个将变量的已有类型更改为新指定类型的操作，它的基本语法是 `as NewType`

- 需要注意的是，类型断言应当是在迫不得己的情况下使用的。虽然说我们可以用类型断言纠正不正确的类型分析，但类型分析在大部分场景下还是可以智能地满足我们需求的

- 非空断言其实是类型断言的简化，它使用 `!` 语法，即 `obj!.func()!.prop` 的形式标记前面的一个声明一定是非空的



#### 类型层级

- 最顶级的类型，any 与 unknown

- 特殊的 Object ，它也包含了所有的类型，但和 Top Type 比还是差了一层

- String、Boolean、Number 这些装箱类型

- 原始类型与对象类型

- 字面量类型，即更精确的原始类型与对象类型嘛，需要注意的是 null 和 undefined 并不是字面量类型的子类型

- 最底层的 never



    








