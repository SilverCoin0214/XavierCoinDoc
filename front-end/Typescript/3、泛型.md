### 类型别名中的泛型

- 类型别名中的泛型大多是用来进行工具类型封装

- 在条件类型参与的情况下，通常泛型会被作为条件类型中的判断条件（`T extends Condition`，或者 `Type extends T`）以及返回值（即 `:` 两端的值）

### 泛型约束与默认值

- 像函数可以声明一个参数的默认值一样，泛型同样有着默认值的设定

- 泛型还能做到一样函数参数做不到的事：**泛型约束**。也就是说，你可以要求传入这个工具类型的泛型必须符合某些条件，否则你就拒绝进行后面的逻辑。

- 在泛型中，我们可以使用 `extends` 关键字来约束传入的泛型参数必须符合要求

- 关于 extends，`A extends B` 意味着 **A 是 B 的子类型**，这里我们暂时只需要了解非常简单的判断逻辑，也就是说 A 比 B 的类型更精确，或者说更复杂
  
  - 更精确，如**字面量类型是对应原始类型的子类型**
  
  - 更复杂，如 `{ name: string }` 是 `{}` 的子类型，因为在 `{}` 的基础上增加了额外的类型，基类与派生类（父类与子类）同理

- 在 TypeScript 中，泛型参数存在默认约束（在下面的函数泛型、Class 泛型中也是）。这个默认约束值在 TS 3.9 版本以前是 any，而在 3.9 版本以后则为 unknown。

### 多泛型关联

- **多泛型参数其实就像接受更多参数的函数，其内部的运行逻辑（类型操作）会更加抽象，表现在参数（泛型参数）需要进行的逻辑运算（类型操作）会更加复杂**

## 对象类型中的泛型

- 泛型嵌套

## 函数中的泛型

```typescript
function handle<T>(input: T): T {}
```

我们为函数声明了一个泛型参数 T，并将参数的类型与返回值类型指向这个泛型参数。这样，在这个函数接收到参数时，**T 会自动地被填充为这个参数的类型**。这也就意味着你不再需要预先确定参数的可能类型了，而**在返回值与参数类型关联的情况下，也可以通过泛型参数来进行运算**。

- 在基于参数类型进行填充泛型时，其类型信息会被推断到尽可能精确的程度，如这里会**推导到字面量类型而不是基础类型**。这是因为在直接传入一个值时，这个值是不会再被修改的，因此可以推导到最精确的程度。而如果你使用一个变量作为参数，那么只会使用这个变量标注的类型

- 函数的泛型是日常使用较多的一部分，更明显地体现了**泛型在调用时被填充**这一特性，而类型别名中，我们更多是手动传入泛型。这一差异的缘由其实就是它们的场景不同，我们通常使用类型别名来**对已经确定的类型结构进行类型操作**，比如将一组确定的类型放置在一起。

## Class 中的泛型

- Class 中的泛型和函数中的泛型非常类似，只不过函数中泛型参数的消费方是参数和返回值类型，Class 中的泛型消费方则是属性、方法、乃至装饰器等。同时 Class 内的方法还可以再声明自己独有的泛型参数。



### 总结

- 泛型的本质：基于调用时类型推导来自动填充类型参数，从而让多个位置上的类型存在约束或关联，实现更严格的类型保护。

- 
