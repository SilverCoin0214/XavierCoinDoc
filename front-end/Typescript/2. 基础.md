1.  在ts中, 使用`:` 指定变量的类型, `:`的前后有没有空格都可以.
2. 编译为js后, 不会存在类型检查的代码. 是因为ts只会在编译时对类型进行静态检查, 如果发现有错误, 编译时就会报错. 而到了运行时, 就跟js中运行的一致.
3. ts编译的时候及时报错了 , 也还是会生成编译结果, 也就是编译成js代码.


## 原始数据类型
---
### 布尔值
```ts
let isDone: boolean = false;
```
使用构造函数 Boolean 创造的对象不是布尔类型, 而是Boolean对象.
```ts
let booleanObject: boolean = new Boolean(1)  // 报错
```

### number
```ts
let binaryNum: number = 0b1010;
```
number数值类型跟js基本无异

### 字符串
```ts
let str: string = '测试'
let sentence: string = `模板字符串使用 ${str}`
```
string编译后依旧跟js无异

### 空值
在js中没有void的概念, 在ts中, 可以用void表示没有任何返回值的函数

声明一个void类型后只能赋值为 null 或者 undefined.
```ts
let unusable: void = undefined;
```

### null 和 undefined
在ts中, undefined和null是所有类型的子类型. 也就是说 其他类型可以赋值为 null 或者 undefined.

```ts
let num: number = undefined;
```

## 任意值
---
- 声明一个变量为any类型后, 对它的任何操作, 返回的内容的类型都是任意值. 编译时不会报错. 
- 如果变量未声明, 未指定类型, 那么ts也会将之类型定义为 any
```ts
let something;
something = '123'
something = 123  // 不会编译报错
```

## 类型推论
---
当对一个变量赋值却没指定类型时, ts会依照类型推论的规则给变量一个类型.

## 联合类型
---
- 联合类型使用 | 做分隔符, 表示可以是多种类型中的一条
- 要访问联合类型的属性或方法, 只能访问此联合类型的所有类型共有的属性和方法
- 联合类型的变量在被赋值的时候, 会根据类型推论的规则推断出一个类型, 此时之后就可以使用该类型的属性或方法

## 接口
---


