### 微前端特性
- 在聚合的过程中需要一个容器应用（主应用），主应用通过设计导航将各个拆分的小型应用（微应用）聚合在一起，可以根据导航进行微应用的切换。
![](https://s2.loli.net/2024/03/14/bDBsMCFEqi8SLwo.png)
- 主应用的导航可以是前端框架react或者vue的路由，也可以是后端服务路由。还可以是前端自己设计的切换逻辑
	-  如果主应用是 SPA 应用，此时导航是路由跳转，根据前端路由进行微应用切换；
	- 如果主应用是 MPA 应用，此时导航是链接跳转，根据后端路由进行微应用切换；
	- SPA 和 MPA 应用都可以通过其他方式来切换微应用，例如动态切换微应用的 Script
	- 除此之外，复杂的业务场景还可以是上述几种方案的结合体
- 拆分的微应用需要具备 独立开发，独立部署和独立也运行的特性：
	- 微应用可以采用不同的技术栈，支持**独立开发；**
	- 微应用可以单独部署到不同的服务器上，支持**独立部署；**
	- 微应用的运行可以不依赖其他微应用，支持**独立运行。**


## iframe方案
- 简述浏览器多进程架构的优点？
	- 自答： 每个标签页都有自己的一个renderer进程，彼此之间不互相干扰。
	- 不同进程能分管不同的进程，进行合理的资源调配
- Chrome 浏览器中存在哪些进程？
	- 自答： 
	- browser主进程
	- renderer进程
	- GPU进程
	- 网络进程
	- UI进程
	- 存储进程
	- 插件进程
	- 设备进程
- 浏览器中的 Browser 主进程和 Renderer 进程有什么作用？
	- 主进程负责资源调配，处理网络请求，UI事件，文件访问，cookie数据存储等
	- Renderer进程负责标签页所在的web应用的UI渲染和JS执行。
- 从新开一个标签页开始，讲述一下网页生成的整个过程？
	- 
- 简述浏览器的沙箱设计？
	- Browser会对每一个Renderer进程建立沙箱，用于提升安全性。
	- 默认第三方web都是不受信任需要隔离的。
	- 如果Renderer进程需要一些系统操作，需要通过IPC通信通知Brower来进行代理操作。
- Chrome 浏览器的插件进程是否已经沙箱化？
	- 自答： 插件进程是单独的进程，所以已经沙箱化

	GLM:
	- Chrome 浏览器的插件进程已经实现了沙箱化。沙箱是一种安全机制，用于限制程序的访问权限，以防止恶意软件执行可能危害系统安全的操作。
	- Chrome 浏览器通过沙箱技术限制插件的权限，使得插件只能在沙箱环境中运行，无法直接访问操作系统的底层资源和文件系统。这种机制有助于保护用户免受恶意插件的侵害，并防止插件对系统安全造成威胁。
- 什么是浏览器的同源策略？它有什么作用？
	- 自答：同源策略指的是 协议，主机名和端口名全都一致的网页就是同源。
	- 作用在于防止跨域，隔离恶意文档来减少安全风险。
		- 诸如获取一个网站的cookie数据，保存的密码数据等
- 多个跨站的 Web 应用处于同一个 Renderer 进程会有什么安全风险？
	- 自答：获取跨站点web的cookie和html5存储数据
	- 获取web站点的HTML, XML,和JSON数据
	- 获取浏览器保存的密码数据
	- 共享跨站点web应用的授权权限
	- 获取跨站点应用的DOM元素
	
- 什么是站点隔离？它有什么作用？
	- 自答： 站点隔离是是浏览器为不同的站点web应用分配不同的Renderer进程
	- 作用是能够基于沙箱机制对不同应用进行隔离，确保安全性。

- 什么情况下浏览器会给标签页（iframe）分配不同的 Renderer 进程？
	- 自答：如果iframe里是属于跨站的web应用，就会被分配不同的renderer进程。
	
- 为什么浏览器设计成站点隔离，而不是同源策略的源隔离？
	- 自答：使用跨站而不使用跨域来独立Renderer进程是为了兼容现有的浏览器能力。
	- 如果采用同源策略，会导致存在同站应用无法通信的情况。
	
- 跨站和跨域有什么区别？跨域的应用一定跨站吗？
	- 自答： 跨站是指只要 有效顶级域名和二级域名相同，就是同站。
	- 跨域的要求是同源策略，会更加严格，需要协议，主机和端口一致。
	- 所以跨域的应用一定跨站。
- iframe 和浏览上下文存在什么关系？
	- 自答： 每一个iframe都有自己的浏览上下文。
- 在微前端中如何识别微应用是在 iframe 中打开？
	- 
- 微前端中的 iframe 方案有什么优点和缺点？
	- 自答： 
		- 优点：站点隔离和浏览上下文隔离，可以使微应用运行时天然隔离，适合集成三方应用
		- 移植性和复用性好，可以便捷的嵌入在不同的主应用中
		- 缺点： 主应用刷新时，iframe无法保持URL状态
		- 主应用和ifame处于不同的浏览上下文，无法使iframe中的模态框相对主应用居中
		- 主应用和iframe微应用的数据状态同步问题：持久化数据和通信
- 在浏览器中绕过同源策略限制的解决方案有哪些？是否存在安全风险？


### NPM方案

- 为什么 JavaScript 需要模块化规范？
	- 早期按照文件引入在复杂程度上升后容易导致变量名冲突
- 为什么在浏览器中使用 ES Module 规范开发需要通过 HTTP 请求的形式？
	- 因为浏览器中的JS是收到沙箱限制无法直接访问本地文件的，所以只能通过HTTP请求的形式来获取
	- 一个import导入就是一条http请求
- 在浏览器中使用 ES Module 规范进行开发的优势有哪些？
	- 不需要构建工具进行打包处理
	- 天然的按需引入，并且不需要考虑模块的加载顺序问题
	- 模块化作用域，不需要考虑变量名冲突问题
- 浏览器中如何设置 ES Module 引入路径的别名？
	- 
- CommonJS 模块和 ES Module 模块有什么区别？
	- 
- Vite 开发态热更新速度快的主要原因是什么？
	- 
- 为什么需要在 Web 应用的开发中使用 Webpack、Vite、ESBuild 等工具？
	- 
- 大部分浏览器兼容的最高 ECMAScript 标准是多少？
	- 
- 为什么需要对业务组件进行产物构建发布？如果不构建直接发布源码会有什么问题吗？
	- 
- 业务组件和 Web 应用的产物构建存在哪些差异？
- 为什么大部分应用使用 babel-loader 进行转义时推荐屏蔽 node_modules 目录？
- 在什么情况下对应用和业务组件进行构建时需要使用 Polyfill?
- 使用 Rollup 和 Webpack 等构建输出的 ES Module 模块和 ES6+ 源码存在什么区别？
- 使用构建工具构建 ES Module 模块的好处是什么？
- 微前端中的微应用和业务组件的构建存在什么差异？
- 微前端 NPM 方案有什么优点和缺点？
	- 优点： 
	- 微应用可以使用不同的技术栈进行开发
	- 微应用不需要进行静态资源托管，只需要发布到NPM仓库即可
	- 移植性和复用性好，可以便捷的嵌在不同的主应用中
	- 微应用和主应用共享浏览器的Renderer进程，浏览上下文和内存数据

	- 缺点：
	- 需要处理主应用和各个微应用的全局变量，CSS样式和存储数据的冲突问题
	- 微应用的构建需要做额外的配置，构建的不是应用程序，而是JS库
	- 微应用发布后，主应用需要重新安装依赖并且重新部署
	- 如果微应用的资源过大，需要对微应用的构建进行资源优化处理
	- 主应用集成的微应用过多，也会导致构建多份重复框架带来的构建体积过大的问题
- 微前端 NPM 方案适用于哪些业务场景？
	- NPM设计仅仅适合集成一些小型的微应用
- 如何解决在主应用中实时调试微应用 NPM 包的源码问题？

微应用 A / B / C 可以采用不同的技术栈，但是构建时需要像发布业务组件一样输出 ES5 & 模块化标准的 JavaScript 库（尽管开发的是应用，但是构建的不是应用程序，不需要额外生成 HTML），从而使主应用安装各自的依赖时，可以通过模块化的方式引入微应用。主应用不需要关心微应用的技术栈，不需要关心微应用的构建配置项
![](https://s2.loli.net/2024/03/15/3WJjt9o5QPunseC.png)

## 动态 Script 方案

- 微前端中的动态 Script 方案如何实现？
	- 主应用HTML渲染之后：
		- 通过请求获取微应用列表数据，动态进行微应用的预获取和导航创建处理
		- 根据导航进行微应用的切换，切换的过程会动态加载和执行JS和CSS资源
		- 微应用需要提供mount和unmount全局函数，方便主应用进行加载和卸载处理
		![](https://s2.loli.net/2024/03/18/CTsvrz9nGFuBQqW.png)
- 在动态 Script 方案中如何实现 CSS 样式的激活和失效？
- 通过 `script` 标签动态加载 JS 文件后删除 `script` 标签，JS 文件的代码还会执行吗？
- 针对上述问题，如果删除 JS 文件后代码不执行，会有什么副作用？
- 删除 JS 文件和删除后再次添加有什么区别？
- 通过 `link` 标签动态加载 CSS 文件后删除 `link` 标签，CSS 文件对应的样式还会生效吗？
- 微前端动态 Script 方案相对于 NPM 方案有哪些优势？
	- 主应用在线上运行时可以动态增加，删除和更新需要上架的微应用
	- 微应用可以进行构建时的性能优化，包括代码分割和静态资源分离处理
	- 不需要额外对微应用进行库构建配置去适配NPM包的模块化加载方式
- 微前端动态 Script 方案存在哪些问题？
	- 主应用和各个微应用的全局变量会产生属性冲突
	- 主应用和各个微应用的CSS样式会产生冲突

## Web Components 方案
- 微前端中的Web Components方案如何实现？
	- 通过请求获取后端的微应用列表数据，动态进行微应用的预获取和导航创建处理
	- 根据导航进行微应用切换，切换的过程会动态加载并执行JS和CSS
	- JS执行后会在主应用中添加微应用对应的自定义元素，从而实现微应用的加载
	- 如果已经加载微应用对应的JS和CSS，再次切换只需对自定义元素进行显示和隐藏操作
	- 微应用自定义元素会根据内部的生命周期函数在被添加和删除DOM时进行加载和卸载处理
	 ![](https://s2.loli.net/2024/03/18/moME2OYGlRdc7Hu.png)
- 什么是 Web Components?
	- Web Components 可以理解为浏览器的原生组件，它通过组件化的方式封装微应用，从而实现应用自治。
- Web Components 的浏览器兼容情况？如何处理浏览器的兼容性问题？
- Web Components 的生命周期回调函数有哪些？
	- connectedCallback
	- disconnectedCallback
	- mount
	- unmount
- Web Components 相对于动态 Script 方案有哪些优势？
	- 复用性： 不需要对外抛出加载和卸载的全局API, 可复用能力强
	- 标准化： W3C标准，未来能力会得到持续升级
	- 插拔性： 可以非常便捷的进行移植和组件替换
	- 劣势：
		- 兼容性：对于IE浏览器不兼容
		- 学习曲线： 相对于传统web开发，需要掌握新概念和技术

