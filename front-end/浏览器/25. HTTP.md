## 超文本传输协议 HTTP/0.9

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302021624315.png)

-   第一个是只有一个请求行，并没有HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。
-   第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
-   第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。

---


## 被浏览器推动的 HTTP/1.0

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302021627554.png)

HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。

HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性

-   有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。
-   为了减轻服务器的压力，在 HTTP/1.0 中提供了Cache 机制，用来缓存已经下载过的数据。
-   服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段

---

## HTTP/1.1

### 1. 改进持久连接

HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。

持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。

### 2. 不成熟的 HTTP 管线化

### 3. 提供虚拟主机的支持

### 4. 对动态生成的内容提供了完美支持

在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。

HTTP/1.1 通过引入Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。

### 5. 客户端 Cookie、安全机制


---

# HTTP2

## HTTP/1.1 的主要问题

1. HTTP/1.1对于带宽的利用率不理想， 页面加载资源最大只能达到2.5M/S
	1. **第一个原因，TCP 的慢启动。**
		1. TCP协议在最开始时会以非常慢的速度发送数据，然后慢慢加快直到理想状态
	2. **第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。**
	3. **第三个原因，HTTP/1.1 队头阻塞的问题。**
		1. 持久连接时，虽然能公用一个TCP管道，但是管道在同一个时刻，只能处理一个请求。在请求结束之前，其他请求处于阻塞状态。

HTTP/1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。

##   HTTP/2 的多路复用

HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。

对于对头阻塞问题， HTTP/2解决的方式是对资源的并行请求。

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302021648857.png)

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302021652380.png)

-   首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
-   这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
-   服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
-   然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
-   同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
-   浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求


### 1. 可以设置请求的优先级
### 2. 服务器推送
### 3. 头部压缩

---

# HTTP3

## TCP 的队头阻塞

在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302021701357.png)

在HTTP/2中，多个请求只跑在一个TCP管道中的。如果其中任意一路的数据流中出现了丢包的情况，就会阻塞TCP连接中的所有请求。

HTTP/1.1有开启6个TCP链接，所以如果1个TCP连接发生队头阻塞，其他5个连接依旧可以继续传输。

## TCP 建立连接的延时

HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。

-   在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
-   进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT

## TCP 协议僵化

---

## QUIC 协议

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302021707576.png)

-   实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。
-   集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。
-   实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302021709942.png)




