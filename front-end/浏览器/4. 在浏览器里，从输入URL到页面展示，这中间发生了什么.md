![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202301311008091.png)

-   首先，用户从浏览器进程里输入请求信息；
-   然后，网络进程发起URL请求；
-   服务器响应URL请求之后，浏览器进程就又要开始准备渲染进程了；
-   渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；
-   渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

---

### 1. 用户输入
当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的URL。

### 2. URL请求过程
浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

首先，网络进程会先查本地缓存是否缓存了该资源。如果有缓存资源，直接返回资源给浏览器进程。 如果没有缓存资源，那么进入网络请求流程。 第一步先进行DNS解析，获得域名对应的ip地址和端口号。如果请求协议是HTTPS，还要建立TLS连接。

接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，浏览器会构建请求行，请求头等信息， 并把和该域名相关的Cookie数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接到信息之后，会根据请求信息生成响应数据。并发送给网络进程。等网络进程接收到响应信息后，就开始解析响应头的内容了。

**（1）重定向**
在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，一切又重头开始了。

**（2）响应数据类型处理**

请求类型有可能是下载类型，又或者就是HTML页面，需要通过响应头里的Content-Type字段来区分。

不同Content-Type的后续处理流程也截然不同。如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进行导航流程。

### 3. 准备渲染进程

-   通常情况下，打开新的页面都会使用单独的渲染进程；
-   如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

### 4. 提交文档

这里的“文档”是指URL请求的响应体数据。

-   “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
-   等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
-   浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。

### 5. 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了。

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

1. 构建DOM树
	1. **为什么要构建DOM树呢**？这是因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树。
	2. DOM树是保存在内存中的树状结构
2. 样式计算
	1. 把css转换为浏览器可以理解的结构
		1. 渲染引擎会把获取到的CSS文本全部转换为styleSheets结构中的数据，并且该结构同时具备了查询和修改功能
	2. 转换样式表中的属性值，使其标准化
	3. 计算出DOM树中每个节点的具体样式
		1. CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式。
		2. 样式层叠
3. 布局阶段
	1. 创建布局树
		1. 遍历DOM树种所有可见节点，并把这些节点加入到布局中
		2. 不可见的节点会被布局树给忽略掉
	2.  布局计算
		1. 计算布局树节点都坐标位置
4. 分层 -- 图层树
	1. 通常情况下，并不是每个节点都都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。
	2.  拥有层叠上下文属性的元素会被提升为单独的一层。
	3. 需要裁剪的地方也会被创建为图层。
![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202301311427280.png)

5. 图层绘制
	1. 在图层树构建完成之后，渲染引擎会对图层树中每个图层进行绘制。 绘制会拆成很多小的绘制指令，按照指令顺序
6. 栅格化（raster）操作
	1. 绘制列表只是用来记录绘制顺序和绘制指令的列表，实际上绘制操作是由渲染引擎中的合成线程来完成的。
	2. 
7. 合成和显示
	1. 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 “DrawQuad”, 然后将该命令提交给浏览器进程。
	2. 浏览器进程里面有一个叫做viz的组件，用来接收合成进程发过来的DrawQuad命令，然后根据DrawQuad命令， 将其页面内容绘制到内存中，最后再显示到屏幕上。


---

# 总结： 在浏览器里，从输入URL到页面展示，这中间发生了什么

- 用户输入url并回车
- 浏览器进程检查url，组装协议，构成完整的url
- 浏览器进程通过通信间协议IPC把url请求发送给网络进程
- 网络进程接收到url请求后检查本地缓存是否缓存了请求资源，如果有则返回该资源给浏览器进程
- 如果没有，网络进程向web服务器发起http请求， 请求流程如下
	- 进行DNS解析，获得服务器ip地址，端口号
	- 利用ip地址和服务器建立TCP连接
	- 构建请求头信息
	- 发送请求头信息
	- 服务器响应后， 网络进程接收响应头和响应信息，并解析响应内容
- 网络进程解析响应流程
	- 检查状态码。 如果是301或302，执行重定向。 如果是200，则继续处理请求
	- 200响应处理，先检查响应类型Content-Type, 如果是字节流类型，则交给下载管理器，导航流程结束，不在进行后续渲染。 如果是html则通过浏览器进程通知渲染进程开始准备渲染
- 准备渲染进程
	- 浏览器进程检查当前url是否和之前打开的渲染进程有相同的根域名，相同则复用。
- 传输数据，更新状态
	- 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的信息，渲染进程接收到信息和网络进程建立传输数据的管道
	- 渲染进程接收完数据之后，向浏览器进程发送 确认提交
	- 浏览器进程收到确认消息后更新浏览器界面状态，更新web界面
- 开始渲染阶段
	- 渲染进程将HTML内容转换成浏览器能够读懂的DOM树结构
	- 渲染引擎将CSS样式列表转化为浏览器可以理解的StyleSheet,  计算出DOM节点样式
	- 创建布局树，并计算元素的布局信息
	- 对布局树进行分层， 创建图层树
	- 对每个图层生成绘制列表， 并提交给合成线程
	- 合成线程将图层分为图块， 并在光栅化线程池中将图块转换成位图。
	- 合成线程发送绘制图块命令DrawQuad给浏览器进程
	- 浏览器进程根据DrawQuad消息在内存中生成页面，并显示到显示器上。



---

### 1. 更新了元素的几何属性（重排）Reflow
![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202301311541508.png)

Reflow会导致浏览器重新触发布局，所以重新解析之后的所有步骤，导致渲染流程全部都需要更新。

### 2. 更新元素的绘制属性（重绘）Repaint
![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202301311544336.png)

RePaint不会影响布局，所以直接进入绘制， 相较于Reflow，省去了布局和分层阶段，效率相对更高。


### 3. 直接合成阶段
合成是指既不需要布局也不需要绘制的属性变更，渲染引擎直接跳过布局和绘制，直接执行后续合成操作。

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202301311552235.png)







