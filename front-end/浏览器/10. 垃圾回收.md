

## 调用栈中的数据是如何回收的

当前状态指针 ESP

当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

## 堆中的数据是如何回收的

### 代际假说
- 第一个是大部分对象在内存中存在的时间很短，很多对象一经分配，很快就变得不可访问
- 第二个是不死的对象，会活的更久

V8中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。

新生区通常只支持1-8M的容量，老生区的容量会大很多。对于两个区域, V8采用两个不同的垃圾回收器，分配不同的垃圾回收算法。
- 副垃圾回收器， 负责新生区垃圾回收
- 主垃圾回收器， 负责老生区垃圾回收


###  执行流程

- 第一步标记空间中活动对象和非活动对象，
- 回收非活动对象所占用的内存。 标记完成后，统一清理内存中所有被标记为可回收的对象。
- 内存整理， 频繁回收对象后，内存中会存在大量不连续的空间，称为内存碎片。通过整理碎片，来获取连续的大内存空间。 不过不是所有垃圾回收器都需要整理，因为有些不会产生碎片。


##   副垃圾回收器

新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302011128390.png)

新加入的对象会被放到对象区域，当对象区域快满的时候会开始进行垃圾清理操作。

对对象区域里的对象进行标记，需要被回收的就清理掉，剩下存活的对象有序的排列后复制到空闲区域中。

完成复制后， 对象区域和空闲区域进行翻转。

如果发现存活的对象经历过两次垃圾回收还存在，那么就转移到老生区。

## 主垃圾回收器

老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

老生区采用的算法是标记清除算法。

标记过程就是， 从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能够被遍历到的对象称为活动对象，没有被遍历到的元素就是可以清除的对象。

垃圾清除过程与副垃圾回收器的清除过程不同。因为堆中的地址片段可能是不连续的。
再之后还需要有整理的过程。 标记整理算法。

![](https://raw.githubusercontent.com/SilverCoin0214/XavierCoinPic/main/image/%08js/202302011356503.png)

## 全停顿

javascript是运行在主线程之上的，一旦执行垃圾回收算法，就需要将js脚本停下来。等待垃圾回收完毕再继续执行，这种行为叫做 stop the world。 

如果垃圾过大，时间开销增加，就会导致性能下降。

为了降低老生代的垃圾回收造成的卡顿，V8将标记过程分为一个个子标记过程，同时让垃圾回收标记和javascript应用逻辑交替进行，直到标记阶段完成。 这个算法称为 增量标记。








