要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。

处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 延迟队列。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。


clearTimeout取消定时器操作，就是在设置定时器时，js引擎会返回一个定时器的ID, 如果要取消还没执行的定时器，那么就直接在延迟消息队列中找到对应ID的任务，删除就行。


## 使用 setTimeout 的一些注意事项

**1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行**
- setTimout设置延迟时间为0毫秒，不代表一定就0毫秒后立马执行，如果当前执行的任务耗时过长，那它就只能在这任务之后才能立马执行。

**2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒**
- 在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。

**3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒**
- 未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

**4. 延时执行时间有最大值**
- 32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出

**5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉**
- 如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象

