## 时间分片
---
- 时间分片主要解决， 初次加载， 一次性渲染大量数据造成的卡顿现象。

**浏览器执 js 速度要比渲染 DOM 速度快的多。**时间分片，并没有本质减少浏览器的工作量，而是把一次性任务分割开来，给用户一种流畅的体验效果。就像造一个房子，如果一口气完成，那么会把人累死，所以可以设置任务，每次完成任务一部分，这样就能有效合理地解决问题。

主要思路：
- 计算时间片， 用eachRenderNum代表一次渲染多少个，那么总数据除以eachRenderNum就能知道渲染多少次
- 开始渲染数据，通过 index > times判断渲染完成， 如果没有完成，那么通过 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一帧渲染
- 通过 renderList把已经渲染的element缓存起来， 这样可以跳过下一次渲染，实际每次渲染数量都会是eachRenderNum的个数。

## 虚拟列表
---
何为虚拟列表，就是在长列表滚动过程中，只有视图区域显示的是真实 DOM ，滚动过程中，不断截取视图的有效区域，让人视觉上感觉列表是在滚动。达到无限滚动的效果。

虚拟列表划分为三个区域： 视图区 + 缓冲区 + 虚拟区
- 视图区： 用户看到的列表区，元素都是真实DOM
- 缓冲区： 一样渲染的是真实DOM，为了防止上滑和下滑导致的白屏，需要一部分缓冲区
- 虚拟区： 不需要渲染真实的DOM元素。 

实现思路：
-   通过 useRef 获取元素，缓存变量。
-   useEffect 初始化计算容器的高度。截取初始化列表长度。这里需要 div 占位，撑起滚动条。
-   通过监听滚动容器的 onScroll 事件，根据 scrollTop 来计算渲染区域向上偏移量, 这里需要注意的是，当用户向下滑动的时候，为了渲染区域，能在可视区域内，可视区域要向上滚动；当用户向上滑动的时候，可视区域要向下滚动。
-   通过重新计算 end 和 start 来重新渲染列表。

 



